package com.st0ck53y.testsudokuapplication;

import com.st0ck53y.testsudokuapplication.classes.ImageProcessor;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SeparableConvolutionTest {



    @Test
    public void rndSepTest() {
        //values randomly generated by random.org

        //10x10 'images' 3 used just to be sure its not a coincidence
        int[] img1 = {131, 14, 167, 53, 32, 98, 225, 148, 236, 165, 170, 71, 95, 184, 195, 106, 215, 15, 154, 253, 151, 246, 191, 18, 130, 139, 205, 156, 114, 119, 175, 183, 237, 29, 117, 37, 216, 177, 112, 198, 230, 179, 21, 73, 59, 226, 41, 8, 178, 141, 63, 47, 88, 251, 252, 85, 222, 213, 24, 111, 101, 185, 160, 113, 146, 232, 31, 127, 49, 211, 56, 166, 158, 249, 204, 52, 36, 231, 40, 235, 25, 46, 129, 55, 193, 228, 250, 161, 10, 219, 51, 218, 152, 142, 6, 172, 76, 70, 1, 102};
        int[] img2 = {230, 15, 131, 120, 134, 3, 74, 150, 22, 76, 160, 140, 61, 111, 26, 192, 179, 96, 24, 59, 205, 56, 113, 222, 40, 41, 38, 162, 195, 240, 46, 122, 212, 77, 208, 209, 124, 5, 223, 84, 202, 187, 158, 98, 201, 149, 248, 173, 215, 7, 225, 11, 167, 238, 42, 94, 169, 156, 57, 142, 117, 108, 249, 54, 170, 193, 68, 43, 82, 219, 4, 28, 102, 110, 69, 180, 25, 198, 1, 12, 6, 176, 30, 132, 229, 83, 49, 236, 63, 58, 196, 81, 233, 147, 203, 163, 235, 86, 107, 65};
        int[] img3 = {223, 184, 171, 237, 89, 96, 172, 151, 63, 190, 178, 47, 161, 134, 73, 50, 189, 13, 163, 170, 132, 217, 147, 243, 252, 231, 40, 236, 45, 164, 113, 25, 90, 188, 246, 52, 121, 49, 59, 117, 24, 22, 8, 101, 84, 230, 33, 155, 20, 218, 145, 109, 179, 51, 54, 115, 242, 127, 6, 98, 94, 202, 212, 71, 191, 1, 159, 232, 187, 2, 65, 201, 144, 216, 83, 235, 174, 37, 156, 91, 104, 228, 244, 100, 140, 128, 75, 76, 58, 226, 55, 106, 29, 214, 107, 93, 220, 118, 211, 209};

        int[] img1NonSep = ImageProcessor.gaussianBlurNS(img1, 10, 10);
        int[] img2NonSep = ImageProcessor.gaussianBlurNS(img2, 10, 10);
        int[] img3NonSep = ImageProcessor.gaussianBlurNS(img3, 10, 10);

        int[] img1Sep = ImageProcessor.gaussianBlur(img1, 10, 10);
        int[] img2Sep = ImageProcessor.gaussianBlur(img2, 10, 10);
        int[] img3Sep = ImageProcessor.gaussianBlur(img3, 10, 10);

        int[] d = new int[3];
        int[] p = new int[3];
        //not checking borders because they should remain the same for this implementation, and im comparing the internal bluring primarily
        for (int y = 1; y < 9; y++) {
            for (int x = 1; x < 9; x++) {
                if (img1NonSep[y*10 + x] != img1Sep[y*10 + x]) {
                    d[0] += Math.abs(img1NonSep[y*10 + x] - img1Sep[y*10 + x]);
                    p[0]++;
                }
                if (img2NonSep[y*10 + x] != img2Sep[y*10 + x]) {
                    d[1] += Math.abs(img2NonSep[y*10 + x] - img2Sep[y*10 + x]);
                    p[1]++;
                }
                if (img3NonSep[y*10 + x] != img3Sep[y*10 + x]) {
                    d[2] += Math.abs(img3NonSep[y*10 + x] - img3Sep[y*10 + x]);
                    p[2]++;
                }
            }
        }

        System.out.printf("1. avg: %1.4f\n2. avg: %1.4f\n3. avg: %1.4f", ((double)d[0] / p[0]), ((double)d[1] / p[1]), ((double)d[2] / p[2]));
    }

    @Test(expected=java.lang.AssertionError.class) //just testing to see if its shifting causing the accuracy error
    public void sepShift() throws Exception {
        int[] preBlur = {12,29,50,
                40,83,192,
                64,107,242}; //randomly decided to have rough gradient

        int nonSep3 = (preBlur[0] >> 4) +
                (preBlur[1]  >> 3) +
                (preBlur[2]  >> 4) +
                (preBlur[3] >> 3) +
                (preBlur[4] >> 2) +
                (preBlur[5] >> 3) +
                (preBlur[6] >> 4) +
                (preBlur[7] >> 3) +
                (preBlur[8] >> 4);

        int[] sep3Hor = new int[4];
        sep3Hor[0] = (preBlur[0] >> 2) +
                (preBlur[1] >> 1) +
                (preBlur[2] >> 2);

        sep3Hor[1] = (preBlur[3] >> 2) +
                (preBlur[4] >> 1) +
                (preBlur[5] >> 2);

        sep3Hor[2] = (preBlur[6] >> 2) +
                (preBlur[7] >> 1) +
                (preBlur[8] >> 2);

        int sep3 = (sep3Hor[0] >> 2) +
                (sep3Hor[1] >> 1) +
                (sep3Hor[2] >> 2);


        assertEquals(sep3, nonSep3);
    }

    @Test
    public void sep3VsNonSep3() throws Exception {
        double[] preBlur = {12,29,50,
                40,83,192,
                64,107,242}; //randomly decided to have rough gradient

        double nonSep3 = (preBlur[0] * (1/16)) +
                (preBlur[1]  * (1/8)) +
                (preBlur[2]  * (1/16)) +
                (preBlur[3] * (1/8)) +
                (preBlur[4] * (1/4)) +
                (preBlur[5] * (1/8)) +
                (preBlur[6] * (1/16)) +
                (preBlur[7]  * (1/8)) +
                (preBlur[8]  * (1/16));

        double[] sep3Hor = new double[4];
        sep3Hor[0] = (preBlur[0] * (1/4)) +
                (preBlur[1] * (1/2)) +
                (preBlur[2] * (1/4));

        sep3Hor[1] = (preBlur[3] * (1/4)) +
                (preBlur[4] * (1/2)) +
                (preBlur[5] * (1/4));

        sep3Hor[2] = (preBlur[6] * (1/4)) +
                (preBlur[7] * (1/2)) +
                (preBlur[8] * (1/4));

        double sep3 = (sep3Hor[0] * (1/4)) +
                (sep3Hor[1] * (1/2)) +
                (sep3Hor[2] * (1/4));


        assertEquals(sep3, nonSep3, 0.25);
    }
}